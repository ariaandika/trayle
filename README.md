# Rust Wayland Compositor for Learning

based on `smithay` library

## Terms

### backend

interaction with the Operating System, this includes Session Management, Input Handling, and Graphics

- `winit`

smithay provide winit backend based on the `winit` library, that can make compositor
run as wayland or x11 client. Useful for development and debugging.

### Session Management

from smithay docs:

> Session management relates to mechanisms allowing the compositor to access the resources it needs to function.
> It contains interaction with the login manager if any ((e)logind or seatd), as well as releasing those
> resources when TTY-switching.

Compositor will generally need it to run directly on a TTY.

It is handled by smithays `session` module, gated by the `backend_session` cargo feature.
This module is tightly coupled with the `udev` module, which allows the discovery of usable graphics
and input devices on the system, using the udev system daemon.

- `udev`

from [arch wiki](https://wiki.archlinux.org/title/Udev)

> udev is a userspace system that enables the operating system administrator to register userspace handlers
> for events. The events received by udev's daemon are mainly generated by the (Linux) kernel in response
> to physical events relating to peripheral devices.

Compositor can register a handlers to be notifed about physical events relating to peripheral devices.

It is handled by smithays `udev` module, gated by the `backend_udev` cargo feature.

### Input Handling

Compositor can register handlers to be notifed about available input devices and all input events.

It is handled by smithays `input` module. An input provider based on `libinput` is given
in the `libinput` module, gated by the `backend_libinput` cargo feature.

### Graphics

Combining content from the clients and displaying it on the screen is the central role of a wayland compositor.

Smithay provides a rendering infrastructure built around graphics buffers: you retrieve buffers
for your client, you composite them into a new buffer holding the contents of your desktop,
that you will then submit to the hardware for display.

The backbone of this infrastructure is structured around the `allocator` and `renderer` modules.

- `allocator`

Contains generic traits representing the capability to allocate and convert graphical buffers,
as well as an implementation of this capability using GBM (see its module-level docs for details).

- `renderer`

Provides traits representing the capability of graphics rendering using those buffers,
as well as an implementation of this capability using GLes2 (see its module-level docs for details).

- `drm`

Smithay provides the `drm` module, which represents abstraction on top the linux direct rendering manager api (drm).
This module is gated by the `backend_drm` cargo feature.

- `egl`

Smithay provides the `egl` module, which provides the logic to setup an OpenGL context.
It is used by the Gles2 renderer (which is based on OpenGL), and also provides the capability
for clients to use the `wl_drm`-based hardware-acceleration provided by Mesa

